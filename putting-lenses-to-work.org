#+TITLE:  Putting Lenses to Work
#+AUTHOR: John Wiegley
#+EMAIL:  johnw@newartisans.com
#+DATE:   8 Apr 2017

#+DESCRIPTION: A non-theory presentation of using lenses to get stuff done
#+KEYWORDS: lens haskell functional programming
#+LANGUAGE: en

\setbeamertemplate{footline}{}
\setbeamerfont{block body}{size=\small}
\definecolor{orchid}{RGB}{134, 134, 220}
\setbeamercolor{block title}{fg=white,bg=orchid}
\setbeamercolor{bgcolor}{fg=white,bg=blue}

* Overview
** Overview
1. Lenses & Records
2. Prisms & ADTs
3. Maps
4. State
5. Traversals
6. Other lenses
** Introduction
- Non-theory presentation of how we use lenses at BAE Systems

- Applied to the right problem, lenses are indispensible!
* Lenses & Records
** Products
*** Get
### lenses.products.view.operator
*** Set
#+begin_src haskell
(1,2,3) & _2 .~ 20
    ==> (1,20,3)
#+end_src
** Records
- Most tutorials start with records
- Arguably the least interesting use of lens
- In shallow use, barely different from regular access and update syntax
** Records
#+begin_src haskell
{-# LANGUAGE TemplateHaskell #-}

module Lenses where

import Control.Lens

data Record = Record
    { _field1 :: Int
    , _field2 :: Int
    }

makeLenses ''Record
#+end_src
** Records
#+begin_src haskell
ex1 :: Record -> Int
ex1 r = r ^. field1

ex2 :: Record -> Record
ex2 r = r & field1 .~ 1
#+end_src
** Writing lenses
#+begin_src haskell
{-# LANGUAGE ApplicativeDo #-}

mylens :: Lens' (Int, Int) Int
mylens k (p1, p2) = do
  -- 'k' is a function from Int -> f Int
  -- mylens itself is a function
  --     from (Int, Int) -> f (Int, Int)
  p1' <- k p1
  return (p1', p2)
#+end_src
* Prisms & ADTs
** Prisms
** ADTs
* Traversals
** Traversals
** Collections
*** Get
#+begin_src haskell
[1,2,3] ^? ix 1
    ==> Just 2
#+end_src
*** Set
#+begin_src haskell
[1,2,3] & ix 1 .~ 20
    ==> [1,20,3]
#+end_src
** Computations
*** Get
#+begin_src haskell
31415926 ^? digit 2
    ==> Just 4
#+end_src
*** Set
#+begin_src haskell
31415926 & digit 2 .~ 8
    ==> 31815926
#+end_src
** Monoids
** partsOf
** biplate
** Folds
* Maps
** Maps
** at
** non
** failing
* State
** use
** preuse
** zoom
* Other lenses
** ALens, LensLike
** Fold, Getter, Setter
** Indexed lenses
** Computational lenses
** lens-aeson
** thyme


* Colophon

#+STARTUP: beamer
#+STARTUP: content fninline hidestars

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [utf8x,notes,17pt]

#+BEAMER_THEME: [height=16mm] Rochester
#+BEAMER_COLOR: seahorse

#+OPTIONS:   H:2 toc:nil

#+BEAMER_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_HEADER: \usepackage{courier}
#+BEAMER_HEADER: \usepackage{helvet}

#+BEAMER_HEADER: \usepackage{pdfcomment}
#+BEAMER_HEADER: \renewcommand{\note}[1]{\marginnote{\pdfcomment[icon=Note]{#1}}}

#+BEAMER_HEADER: \usepackage{mathtools}
#+BEAMER_HEADER: \SetUnicodeOption{mathletters}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{952}{\theta}

#+BEAMER_HEADER: \usepackage{minted}

# #+name: setup-minted
# #+begin_src emacs-lisp :exports both :results silent
# (setq org-latex-listings 'minted)
# (setq org-latex-minted-options
#       '(("fontsize" "\\footnotesize")
#         ("linenos" "true")))
# #+end_src

#+BEAMER_HEADER: \let\svthefootnote\thefootnote
#+BEAMER_HEADER: \newcommand\blankfootnote[1]{%
#+BEAMER_HEADER:   \let\thefootnote\relax\footnotetext{#1}%
#+BEAMER_HEADER:   \let\thefootnote\svthefootnote%
#+BEAMER_HEADER:   }

#+BEAMER_HEADER: \newcommand{\head}[1]{\begin{center}
#+BEAMER_HEADER: \vspace{13mm}\hspace{-1mm}\Huge{{#1}}
#+BEAMER_HEADER: \end{center}}

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
